package toxi.geom;

#if !java
private typedef Single = Float;
#end

extern class Vec3D implements ReadonlyVec3D {
	public function new(x:Single, y:Single, z:Single):Void;
	public function abs():Vec3D;
	public function add(v:ReadonlyVec3D):Vec3D;
	public function addSelf(v:Vec3D):Vec3D;
	public function angleBetween(v:ReadonlyVec3D, forceNormalize:Bool):Single;
	public function clear():ReadonlyVec3D;
	public function compareTo(v:ReadonlyVec3D):Int;
	public function constrain(min:Vec3D, max:Vec3D):Vec3D;
	public function copy():Vec3D;
	public function cross(v:ReadonlyVec3D):Vec3D;
	public function crossInto(v:ReadonlyVec3D, result:Vec3D):Vec3D;
	public function crossSelf(v:Vec3D):Vec3D;
	public function distanceTo(v:ReadonlyVec3D):Single;
	public function distanceToSquared(v:ReadonlyVec3D):Single;
	public function dot(v:ReadonlyVec3D):Single;
	public function equals(obj:Dynamic):Bool;
	public function equalsWithTolerance(v:ReadonlyVec3D, tolerance:Single):Bool;
	public function floor():Vec3D;
	public function frac():Vec3D;
	static public function fromXYTheta(theta:Single):Vec3D;
	static public function fromXZTheta(theta:Single):Vec3D;
	static public function fromYZTheta(theta:Single):Vec3D;
	public function getAbs():Vec3D;
	public function getComponent(id:Int):Single;
	public function getFloored():Vec3D;
	public function getFrac():Vec3D;
	public function getInverted():Vec3D;
	public function getLimited(lim:Single):Vec3D;
	public function getNormalized():Vec3D;
	public function getNormalizedTo(len:Single):Vec3D;
	public function getReciprocal():Vec3D;
	public function getReflected(normal:ReadonlyVec3D):Vec3D;
	public function getRotatedAroundAxis(axis:ReadonlyVec3D, theta:Single):Vec3D;
	public function getRotatedX(theta:Single):Vec3D;
	public function getRotatedY(theta:Single):Vec3D;
	public function getRotatedZ(theta:Single):Vec3D;
	public function getSignum():Vec3D;
	public function hashCode():Int;
	public function headingXY():Single;
	public function headingXZ():Single;
	public function headingYZ():Single;
	public function immutable():ReadonlyVec3D;
	public function interpolateTo(v:ReadonlyVec3D, f:Single):Vec3D;
	public function interpolateToSelf(v:ReadonlyVec3D, f:Single):Vec3D;
	public function invert():Vec3D;
	public function isInAABB(boxOrigin:Vec3D, boxExtent:Vec3D):Bool;
	public function isMajorAxis(tol:Single):Bool;
	public function isZeroVector():Bool;
	public function jitter(jitterVec:Vec3D):Vec3D;
	public function limit(lim:Single):Vec3D;
	public function magnitude():Single;
	public function magSquared():Single;
	static public function max(a:ReadonlyVec3D, b:ReadonlyVec3D):Vec3D;
	public function maxSelf(b:ReadonlyVec3D):Vec3D;
	static public function min(a:ReadonlyVec3D, b:ReadonlyVec3D):Vec3D;
	public function minSelf(b:ReadonlyVec3D):Vec3D;
	public function modSelf(bx:Single, by:Single, bz:Single):Vec3D;
	public function normalize():Vec3D;
	public function normalizeTo(len:Single):Vec3D;
	static public function randomVector():Vec3D;
	public function reciprocal():Vec3D;
	public function reflect(normal:ReadonlyVec3D):Vec3D;
	public function rotateAroundAxis(axis:ReadonlyVec3D, theta:Single):Vec3D;
	public function rotateX(theta:Single):Vec3D;
	public function rotateY(theta:Single):Vec3D;
	public function rotateZ(theta:Single):Vec3D;
	public function roundToAxis():Vec3D;
	public function scale(s:ReadonlyVec3D):Vec3D;
	public function scaleSelf(s:Vec3D):Vec3D;
	public function set(v:ReadonlyVec3D):Vec3D;
	public function setComponent(id:Int, val:Single):Vec3D;
	public function setXY(v:Vec2D):Vec3D;
	public function shuffle(iterations:Int):Vec3D;
	public function signum():Vec3D;
	public function sub(v:ReadonlyVec3D):Vec3D;
	public function subSelf(v:Vec3D):Vec3D;
	public function to2DXY():Vec2D;
	public function to2DXZ():Vec2D;
	public function to2DYZ():Vec2D;
	public function toArray():java.NativeArray<Single>;
	public function toArray4(w:Single):java.NativeArray<Single>;
	public function toCartesian():Vec3D;
	public function toSpherical():Vec3D;
	public function toString():String;
	public function x():Single;
	public function y():Single;
	public function z():Single;
}
